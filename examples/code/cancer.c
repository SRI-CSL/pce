#include <float.h>
#include <pce.h>

// On 'dampier.ai.sri.com' (a macbook pro), I can compile and link this file using:

// gcc -o ex example1.c -I/opt/pce/git/src -L/opt/pce/git/build/i386-apple-darwin13.4.0-release/lib -lmcsat -llbfgs


/* Appears to be necessary at present: */
samp_table_t samp_table;

/*
  EXAMPLE OF A C-CALLABLE MLN
  -Chris Connolly

  This file implements the "cancer" example as an "embedded"
executable. It illustrates the creation, solution, and printout of a
Markov Logic Network with the libmcsat API.  Most calls are in pretty
good correspondence to mcsat commands.

  The 'add' command is the trickiest, since it involves multiple
levels of function calls to construct a formula and then add it.  Here
is an overview of the ways that formulas can be constructed:

From yacc.y: ADD ofrozen formula addwt oname

ofrozen is empty.

Use 'make_atom' to create an atom.

-- A 'fmla' is a chain of fmla's connected by operators:

fmla = atom_to_fmla(atom) or
fmla = make_fmla(IFF, fmla1, fmla2) or
fmla = make_fmla(IMPLIES, fmla1, fmla2) or
fmla = make_fmla(OR, fmla1, fmla2)
fmla = make_fmla(XOR, fmla1, fmla2)
fmla = make_fmla(AND, fmla1, fmla2)
fmla = make_fmla(NOT, fmla1, NULL)

-- The function 'make_formula' creates a formula with optional
   quantified variables:

formula = make_formula(NULL, fmla) or
formula = make_formula(NAMES, fmla)

-- To seal the deal:

add_cnf(NULL, formula, weight, NULL, true);

It is somewhat disturbing that this function call never mentions the
samp_table_t, and presumably somebody under add_cnf refers to
the 'samp_table' global.


*/


/*
 * This has to be lifted from yacc.tab.h, since it is generated by
 * bison.  Careful, this could conceivably change.  It defines the
 * legal operators for combining fmlas:
 */


enum op_type {
  IFF = 292,
  IMPLIES = 293,
  OR = 294,
  XOR = 295,
  AND = 296,
  NOT = 297,
};


/* Similarly, the enum values for which tables to dump must be lifted
 * from yacc.tab.h:
 */

enum dump_type {
  ALL = 258,
  PROBABILITIES = 260,
  PREDICATE = 261,
  DIRECT = 262,
  INDIRECT = 263,
  CLAUSE = 264,
  RULE = 265,
  SORT = 266,
  SUMMARY = 283,
  QINST = 284,
};

int main(int argc, char **argv) {
  int i, j;
  samp_table_t *table = &samp_table;

  char *fr_args[] = {"Person", "Person", NULL};
  char *other_args[] = {"Person", NULL};


  rand_reset(); // May be reset in options
  //  decode_options(argc, argv);
  init_samp_table(table);

  sort_table_t *sort_table = &table->sort_table;
  var_table_t *var_table = &table->var_table;
  atom_table_t *atom_table = &table->atom_table;

  /* Declare all sorts: */
  add_sort(sort_table, "Person");

  /* Declare all constants: */
  add_constant("Ann", "Person", table);
  add_constant("Bob", "Person", table);
  add_constant("Carl", "Person", table);
  add_constant("Dee", "Person", table);
  add_constant("Earl", "Person", table);
  add_constant("Fran", "Person", table);

  /* The "witness" arg is simply a direct (1) / indirect (0) indicator: */

  /* Declare all predicates: */
  add_predicate("Fr", fr_args, 0, table);
  add_predicate("Sm", other_args, 0, table);
  add_predicate("Ca", other_args, 0, table);
  add_predicate("Frl", other_args, 0, table);

  double weight = 1.0;
  double maxweight = DBL_MAX;
  input_atom_t *atom;
  input_fmla_t *fmla;
  input_formula_t *formula;

  /* Now add the formulae - we should inspect this for regularities
     that can be incorporated into a higher-level API.  */

  // add [x] ~Fr(x,x);
  char *var[] = { "x", NULL };
  char *args1[] = { "x", "x", NULL };
  atom = make_atom("Fr", args1, 0);
  fmla = make_fmla(NOT, atom_to_fmla(atom), NULL);
  formula = make_formula(var, fmla);
  add_cnf(NULL, formula, maxweight, NULL, 1);


  // add [x, y, z] Fr(x, y) and Fr(y, z) => Fr(x, z)  0.7;
  char *vars2[] = { "x", "y", "z", NULL };
  char *a1[] = { "x", "y", NULL };
  char *a2[] = { "y", "z", NULL };
  char *a3[] = { "x", "z", NULL };

  fmla = make_fmla(AND,
		   atom_to_fmla(make_atom("Fr", a1, 0)),
		   atom_to_fmla(make_atom("Fr", a2, 0)));
  fmla = make_fmla(IMPLIES, fmla, atom_to_fmla(make_atom("Fr", a3, 0)));
  formula = make_formula(vars2, fmla);
  add_cnf(NULL, formula, 0.7, NULL, 1);



  // add [x, y] Fr(x, y) => ~Frl(x);
  input_atom_t *atom1;
  char *vars3[] = { "x", "y", NULL };
  char *b1[] = { "x", "y", NULL };
  char *b2[] = { "x",  NULL };
  char *b3[] = { "y",  NULL };
  atom = make_atom("Fr", b1, 0);
  atom1 = make_atom("Frl", b2, 0);
  fmla = make_fmla(NOT, atom_to_fmla(atom1), NULL);
  fmla = make_fmla(IMPLIES, atom_to_fmla(atom), fmla);
  formula = make_formula(vars3, fmla);
  add_cnf(NULL, formula, maxweight, NULL, 1);



  // add [x] Frl(x) => Sm(x)  2.3;
  fmla = make_fmla(IMPLIES, atom_to_fmla(make_atom("Frl", b2, 0)), atom_to_fmla(make_atom("Sm", b2, 0)));
  formula = make_formula(b2, fmla);
  add_cnf(NULL, formula, 2.3, NULL, 1);



  // add [x] Sm(x) => Ca(x)  1.5;
  fmla = make_fmla(IMPLIES, atom_to_fmla(make_atom("Sm", b2, 0)), atom_to_fmla(make_atom("Ca", b2, 0)));
  formula = make_formula(b2, fmla);
  add_cnf(NULL, formula, 1.5, NULL, 1);



  // add [x, y] Fr(x, y) implies (Sm(x) iff Sm(y))  1.1;
  fmla = make_fmla(IMPLIES,
		   atom_to_fmla(make_atom("Sm", b2, 0)),
		   make_fmla(IFF,
			     atom_to_fmla(make_atom("Sm", b2, 0)),
			     atom_to_fmla(make_atom("Sm", b3, 0)))
		   );
  formula = make_formula(b1, fmla);
  add_cnf(NULL, formula, 1.1, NULL, 1);



  //add Fr(Ann, Bob);
  char *ann_bob[] = { "Ann", "Bob", NULL };
  formula = make_formula(NULL, atom_to_fmla(make_atom("Fr", ann_bob, 0)));
  add_cnf(NULL, formula, DBL_MAX, NULL, 1);



  //add Fr(Bob, Carl);
  char *bob_carl[] = { "Bob", "Carl", NULL };
  formula = make_formula(NULL, atom_to_fmla(make_atom("Fr", bob_carl, 0)));
  add_cnf(NULL, formula, DBL_MAX, NULL, 1);



  //add Fr(Dee, Earl);
  char *dee_earl[] = { "Dee", "Earl", NULL };
  formula = make_formula(NULL, atom_to_fmla(make_atom("Fr", dee_earl, 0)));
  add_cnf(NULL, formula, DBL_MAX, NULL, 1);


  // Now solve:
  mc_sat(table, lazy_mcsat(), 10000, // get_max_samples(),
	 get_sa_probability(), get_sa_temperature(),
	 get_rvar_probability(), get_max_flips(),
	 get_max_extra_flips(), get_mcsat_timeout(),
	 get_burn_in_steps(), get_samp_interval());

  // Print the results:
  dumptable(ALL, table);
}
